/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
/*acest proiect contine embeded hello word
 * a fost creat pentru testerea tastaturii 4*4
 */

/*Conecctions to nucleo BRD
 *
 * rows	-	output
 * R1-	PA8
 * R2-	PB10
 * R3-	PB4
 * R4-	PB5
 *
 * column- 	input
 * C1-	PB3
 * C2-	PA10
 * C3-	PA2
 * C4-	PA3
 * (1)
 * */

/*Keyboard 4x4 connection
  			C1-PB3
  			 ^ C2-PA10
 			 |	^ C3-PA2
 			 |	|  ^  C4-PA3
 			 |	|  |  ^
R1-	PA8---->(1)(2)(3)(A)
R2-	PB10--->(4)(5)(6)(B)
R3-	PB4---->(7)(8)(9)(C)
R4-	PB5---->(*)(0)(#)(D)
*/

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include<stdint.h>
#include<stdio.h>

int main(void)
{
  printf("Hello Serghei\n");

/*configure  clock on GPIOA & GPIOB
6.3.10 RCC AHB1 peripheral clock enable register (RCC_AHB1ENR)
Address offset: 0x30
Reset value: 0x0010 0000
Boundary address 0x4002 3800 - 0x4002 3BFF RCC

*/
  uint32_t volatile *const pClockCtrlReg=(uint32_t*) (0x40023800+0x30);	//6.3.10  (RCC_AHB1ENR)

  	  *pClockCtrlReg |= (1<<0); 	//Enable Clock on PortA
  	  *pClockCtrlReg |= (1<<1);		//Enable Clock on PortB
	  *pClockCtrlReg |= (1<<2);		//Enable Clock on PortC
/*configure port mode on GPIO GPIOA & GPIOB
7.4.1 GPIO port mode register (GPIOx_MODER) (x = A..H)
These bits are written by software to configure the I/O direction mode.
00: Input (reset state)
01: General purpose output mode
10: Alternate function mode
11: Analog mode
Address offset: 0x00
Reset values:
• 0xA800 0000 for port A
• 0x0000 0280 for port B
• 0x0000 0000 for other ports
GPIOA Boundary address 0x4002 0000 - 0x4002 03FF
GPIOB Boundary address 0x4002 0400 - 0x4002 07FF
 * */

	uint32_t volatile *const pPortAModeReg=(uint32_t*)0x40020000;
	uint32_t volatile *const pPortBModeReg=(uint32_t*)0x40020400;

//configure mode of port A
//Configure PA8 IO pin as output
	*pPortAModeReg |=(1<<16);//
//Configure PA10 IO pin as input
	*pPortAModeReg &=~(3<<20);//clear 20;21 position
//Configure PA2 IO pin as input
	*pPortAModeReg &=~(3<<4);//clear 4;5 position
//Configure PA3 IO pin as input
	*pPortAModeReg &=~(3<<6);//clear 6;7 position

	//Configure PA5 IO pin as output
		//a. clear 10 and 11 position
		*pPortAModeReg &=~(3<<10);//*pPortAModeReg &= 0xFFFFF3FF;
		//b make 10 position as 1 set
		*pPortAModeReg |= (1<<10);//*pPortAModeReg |= 0x00000400;

//configure mode on port B
//Configure PB10 IO pin as output
	*pPortBModeReg |=(1<<20);//set 20 position
//Configure PB4 IO pin as output
	*pPortBModeReg &=~(1<<9);	//clear 9 position
	*pPortBModeReg |=(1<<8);	//set 8 position
//Configure PB5 IO pin as output
	*pPortBModeReg |=(1<<10);//set 10 position
//Configure PB3 IO pin as input
	*pPortBModeReg &=~(3<<6);//clear 6;7 position

/*	configure pull-up/pull-down register on inputs
 * 7.4.4 GPIO port pull-up/pull-down register (GPIOx_PUPDR) (x = A..H)
 * These bits are written by software to configure the I/O pull-up or pull-down
00: No pull-up, pull-down
01: Pull-up
10: Pull-down
11: Reserved
Address offset: 0x0C
Reset values:
• 0x6400 0000 for port A
• 0x0000 0100 for port B
• 0x0000 0000 for other ports

GPIOA Boundary address 0x4002 0000 - 0x4002 03FF
GPIOB Boundary address 0x4002 0400 - 0x4002 07FF
*/
	uint32_t volatile *const pPortApullUpDownlReg=(uint32_t*)(0x40020000+0x0C);
	uint32_t volatile *const pPortBpullUpDownlReg=(uint32_t*)(0x40020400+0x0C);
	//Configure PA10 IO pin with pull-up
		*pPortApullUpDownlReg |=(1<<20);	//set 21 position
	//Configure PA2 IO pin with pull-up
		*pPortApullUpDownlReg |=(1<<4);		//set 4 position
	//Configure PA3 IO pin with pull-up
		*pPortApullUpDownlReg |=(1<<6);		//set 6 position
	//Configure PB3 IO pin with pull-up
		*pPortBpullUpDownlReg |=(1<<6);		//set 6 position

/*	configure INPUT REG
 * 7.4.5 GPIO port input data register (GPIOx_IDR) (x = A..H)
 * Address offset: 0x10
 *Reset value: 0x0000 XXXX (where X means undefined)
 */
		uint32_t volatile *const pPortAInputReg=(uint32_t*)(0x40020000+0x10);
		uint32_t volatile *const pPortBInputReg=(uint32_t*)(0x40020400+0x10);


//		uint32_t C1=(*pPortBInputReg >> 3) & 0x1;	//C1-PB3
//		uint32_t C2=(*pPortAInputReg >> 10) & 0x1;	//C2-PA10
//		uint32_t C3=(*pPortAInputReg >> 2) & 0x1;	//C3-PA2
//		uint32_t C4=(*pPortAInputReg >> 3) & 0x1;	//C4-PA3

/*Configure OUTPUT REG
 * 7.4.6 GPIO port output data register (GPIOx_ODR) (x = A..H)
Address offset: 0x14
Reset value: 0x0000 0000
 */
		uint32_t volatile *const pPortAOutputReg=(uint32_t*)(0x40020000+0x14);
		uint32_t volatile *const pPortBOutputReg=(uint32_t*)(0x40020400+0x14);


//set outputs on HIGH
//Configure PB10 IO pin as 1
	*pPortBOutputReg |=(1<<10);	//
//Configure PB4 IO pin as 1
	*pPortBOutputReg |=(1<<4);	//
//Configure PB5 IO pin as 1
	*pPortBOutputReg |=(1<<5);	//
//Configure PA8 IO pin as 1
	*pPortAOutputReg |=(1<<8);	//
/*
//set outputs on LOW
//Configure PB10 IO pin as 0
	*pPortBOutputReg &=~(1<<10);//R2
//Configure PB4 IO pin as 0
	*pPortBOutputReg &=~(1<<4);	//R3
//Configure PB5 IO pin as 0
	*pPortBOutputReg &=~(1<<5);	//R4
//Configure PA8 IO pin as 0
	*pPortAOutputReg &=~(1<<8);	//R1
*/

	uint8_t a=0;
while(a<3){
	//turn ONN the LED
		*pPortAOutputReg |=(1<<5);
	for(uint32_t i=0; i<500000; i++);
	//turn OFF LED
		*pPortAOutputReg &=~(1<<5);
	for(uint32_t i=0; i<500000; i++);
a++;
}//end while


while(1){
//verifed buttons on ROW1
	//Configure PA8 IO pin as 0 /Row 1
	*pPortAOutputReg &=~(1<<8);	//R1
	//verifed But1

	uint32_t C1=(*pPortBInputReg >> 3) & 0x1;	//C1-PB3
	if(!C1) {

		uint8_t a=0;
	while(a<1){
		//turn ONN the LED
			*pPortAOutputReg |=(1<<5);
		for(uint32_t i=0; i<500000; i++);
		//turn OFF LED
			*pPortAOutputReg &=~(1<<5);
		for(uint32_t i=0; i<500000; i++);
	a++;
	}//end while

//		printf("But 1 =ON\n");//fflush(stdout);
//	for(uint32_t i=0; i<300000; i++);
	};//end if

	uint32_t C2=(*pPortAInputReg >> 10) & 0x1;	//C2-PA10
	if(!C2){

		uint8_t a=0;
		while(a<2){
			//turn ONN the LED
				*pPortAOutputReg |=(1<<5);
			for(uint32_t i=0; i<500000; i++);
			//turn OFF LED
				*pPortAOutputReg &=~(1<<5);
			for(uint32_t i=0; i<500000; i++);
		a++;
		}//end while

//		printf("But 2 =ON\n");//fflush(stdout);
//	for(uint32_t i=0; i<300000; i++);
	};//end if

	uint32_t C3=(*pPortAInputReg >> 2) & 0x1;	//C3-PA2
	if(!C3){
			printf("But 3 =ON\n");//fflush(stdout);
	//	for(uint32_t i=0; i<300000; i++);
		};//end if

	uint32_t C4=(*pPortAInputReg >> 3) & 0x1;	//C4-PA3
	if(!C4){

			printf("But A =ON\n");//fflush(stdout);
	//	for(uint32_t i=0; i<300000; i++);
		};//end if


	//turn OFF LED
		//	*pPortAOutputReg &=~(1<<5);

	//turn ONN the LED
//				*pPortAOutputReg |=(1<<5);
};//end while

}//end MAIN



